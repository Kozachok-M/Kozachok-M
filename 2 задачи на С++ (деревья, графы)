Задача 1 (Напишите функцию, которая вычисляет глубину бинарного дерева.)
#include <iostream>
#include <algorithm>
using namespace std;

struct Node {
    int val;
    Node* left;
    Node* right;
    Node(int x) : val(x), left(nullptr), right(nullptr) {}
};

int depth(Node* root) {
    if (root == nullptr) return 0;           // Если узел пустой - глубина 0
    int left_depth = depth(root->left);      // Рекурсивно получаем глубину левого поддерева
    int right_depth = depth(root->right);    // Рекурсивно получаем глубину правого поддерева
    return 1 + max(left_depth, right_depth); // Возвращаем 1 + максимальную глубину
}

int main() {
    // Создаем дерево: [1, 2, 3, 4]
    Node* root = new Node(1);
    root->left = new Node(2);
    root->right = new Node(3);
    root->left->left = new Node(4);
    
    int result = depth(root); // Вызываем функцию глубины
    cout << "Глубина дерева: " << result << endl; // Выводим результат
    
    // Очистка памяти
    delete root->left->left;
    delete root->left;
    delete root->right;
    delete root;
    
    return 0;
}
вывод:
Глубина дерева: 3

Задача 2 (проверить существует ли путь между вершинами)
#include <iostream>
#include <unordered_map>
#include <vector>
using namespace std;

bool hasPath(unordered_map<int, vector<int>>& graph, int start, int end) {
    if (start == end) return true;                    // Если дошли до цели - путь найден
    if (graph.find(start) == graph.end()) return false; // Если вершины нет в графе - пути нет
    
    for (int neighbor : graph[start]) {               // Перебираем всех соседей текущей вершины
        if (hasPath(graph, neighbor, end)) return true; // Рекурсивно ищем путь от соседа
    }
    return false; // Если ни один сосед не ведет к цели - путь не существует
}

int main() {
    // Создаем граф: 1 → 2 → 3
    unordered_map<int, vector<int>> graph;
    graph[1] = {2};
    graph[2] = {3};
    
    bool pathExists = hasPath(graph, 1, 3); // Проверяем путь от 1 до 3
    cout << "Путь от 1 до 3 существует: " << (pathExists ? "true" : "false") << endl;
    
    return 0;
}

вывод:
Путь от 1 до 3 существует: true
